#version 460
#extension GL_EXT_ray_tracing : require

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, r32f) uniform image2D shadowImage;  // <-- Format passt zu R32_SFLOAT

layout(push_constant) uniform PushConsts {
    mat4 invViewProj;                 // passt zu C++ (RayTracePushConstants)
    vec3 cameraPos;  float _pad0;
    vec3 lightDirection; float _pad1;
} pc;

// Payload beider Stufen (rgen/rchit/rmiss) identisch halten!
struct PrimaryPayload {
    vec3  hitPos;
    float t;
    uint  hit;
};
layout(location = 0) rayPayloadEXT PrimaryPayload prd;
layout(location = 1) rayPayloadEXT uint occluded;

void tracePrimary(vec3 ro, vec3 rd) {
    prd.hit = 0u;
    prd.t   = 1e30;
    traceRayEXT(
        topLevelAS,
        gl_RayFlagsOpaqueEXT,
        0xFFu,
        0, 1, 0,                  // sbtRecordOffset/Stride/MissIndex (primary miss = 0)
        ro, 0.001, rd, 1e30, 0);
}

void traceShadow(vec3 ro, vec3 rd) {
    occluded = 0u;
    traceRayEXT(
        topLevelAS,
        gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT,
        0xFFu,
        1, 1, 1,                  // shadow miss = 1
        ro, 0.001, rd, 1e30, 1);
}

void main() {
    ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
    vec2  res   = vec2(gl_LaunchSizeEXT.xy);
    vec2  ndc   = (vec2(pixel) + vec2(0.5)) / res * 2.0 - 1.0;

    // Rekonstruiere Weltstrahl aus invViewProj
    vec4 p0 = pc.invViewProj * vec4(ndc, 0.0, 1.0); p0 /= p0.w;
    vec4 p1 = pc.invViewProj * vec4(ndc, 1.0, 1.0); p1 /= p1.w;

    vec3 ro = pc.cameraPos;
    vec3 rd = normalize(p1.xyz - ro);

    tracePrimary(ro, rd);

    float shade = 1.0;
    if (prd.hit == 1u) {
        // kleinen Offset entlang LichtÂ­richtung statt einer (nicht gesetzten) Normale
        vec3 L = normalize(-pc.lightDirection);
        vec3 hitPos = prd.hitPos + L * 0.01;
        traceShadow(hitPos, L);
        shade = (occluded == 1u) ? 0.0 : 1.0;
    }

    imageStore(shadowImage, pixel, vec4(shade, 0.0, 0.0, 1.0));
}
